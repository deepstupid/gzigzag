/*   
RasterFactory1.zob
 *    
 *    Copyright (c) 2000, Ted Nelson and Tuomas Lukka
 *
 *    You may use and distribute under the terms of either the GNU Lesser
 *    General Public License, either version 2 of the license or,
 *    at your choice, any later version. Alternatively, you may use and
 *    distribute under the terms of the XPL.
 *
 *    See the LICENSE.lgpl and LICENSE.xpl files for the specific terms of 
 *    the licenses.
 *
 *    This software is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the README
 *    file for more details.
 *
 */
/*
 * Written by Tuomas Lukka
 */

package org.gzigzag;
import java.util.*;
import java.awt.*;

/** A simple cell factory that gives the cells as one-line strings.
 * Variable length is possible.
 */
 
public class CellFlobFactory1 implements FlobFactory, ZOb {
public static final String rcsid = "$Id$";
    public static boolean dbg = false;
    private static void p(String s) { if(dbg) ZZLogger.log(s); }
    private static void pa(String s) { ZZLogger.log(s); }

    STRUCTPARAMS {
      
	/** The string to use to get the default cell width.  */
	String widthstr
	    = "0000000000";

	/** The default background color. 
	 * XXX Currently, because of color mixing, the foreground
	 * comes from FlobSet. This should maybe change - check later.
	 */
	Color bg
	    = Color.white;

	/** The font for the default enlargement.  */
	ScalableFont font
	    = new ScalableFont("SansSerif", Font.PLAIN, 12);

	/** Whether the font changes size with the enlargement.  */
	boolean zoomfont
	    = true;
	
	/** Whether the font can get bigger than the default font.
	 * Ignored (or rather, doesn't have any effect) when zoomfont is false.
	 */
	boolean enlargefont
	    = true;

	/** The x and y margins
	 */
	int[] margins
	    = new int[] {2, 1};

	/** Whether to produce BallCells instead?
	 */
	 boolean ball
	    = false;
    }

/*
    RasterCellFactory1(Component c) {
	comp = c;
    }
*/

    protected Font fon(int scale) { return font.getFont(scale); }
    protected FontMetrics fonmet(int scale) {
	return font.getFontMetrics(scale);
    }
    protected int getScale(float fract) { return getScale(fract,false); }
    protected int getScale(float fract,boolean real) {
	if(!enlargefont && !real && fract>=1.0) return 1000;
	return (int)(fract*1000);
    }

    public Dimension getSize(ZZCell c, float fract) {
	String str = widthstr;
	if(c != null) str = c.getText();
	if(str == null) str = "";
	FontMetrics fm = fonmet(getScale(fract,true));
	if(ball) 
	    return BallCell.getSize(fm, str, margins[0], margins[1]);
	else 
	    return CellFlob1.getSize(fm, str, margins[0], margins[1]);
    }

    public Flob makeFlob(FlobSet into, ZZCell c, ZZCell handleCell,
		float fract, 
		int x, int y, int d, int w, int h) {
	int scale = getScale(fract);
	Font f = fon(scale);
	FontMetrics fm = fonmet(scale);
	if(ball) {
	    BallCell cf = new BallCell(x, y, d, w, h, handleCell, c, 
				       c.getText(), f, fm, into);
	    cf.xoffs = margins[0];
	    cf.yoffs = margins[1];
	    addSolidColors(into, cf, cf);
	    into.add(cf);
	    return cf;
	} else {
	    CellFlob1 cf = new CellFlob1(x, y, d, w, h, handleCell, c, 
					 c.getText(), f, fm);
	    cf.bg = bg;
	    cf.xoffs = margins[0];
	    cf.yoffs = margins[1];
	    addSolidColors(into, cf, cf);
	    into.add(cf);
	    return cf;
	} 
    }
    public Flob placeFlob(FlobSet into, ZZCell c, ZZCell handleCell,
		    float fract, 
			int x, int y, int depth,
			float xfract, float yfract) {
		Dimension d = getSize(c, fract);
		return makeFlob(into, c, handleCell, fract, 
			(int)(x-xfract*d.width),
			(int)(y-yfract*d.height),
			depth, d.width, d.height);
    }

    public Flob centerFlob(FlobSet into, ZZCell c, ZZCell handleCell,
		float fract, Point p, int xalign, int yalign,
		int depth, Dimension d) {
	if(d == null) d = getSize(c, fract);
	int x, y;
	if(ball) {
	    x = p.x - d.height/2; y = p.y - d.height/2;
	} else {
	    x = p.x - d.width/2; y = p.y - d.height/2;
	}
	if(xalign < 0) x = p.x;
	if(xalign > 0) x = p.x - d.width;
	if(yalign < 0) y = p.y;
	if(yalign > 0) y = p.y - d.height;
	p("centerFlob "+p+" "+d+" at "+x+" "+y+" align "+xalign+" "+yalign);
	return makeFlob(into, c, handleCell, fract, x, y, 
			depth, d.width, d.height);
    }
    public Flob centerFlob(FlobSet into, ZZCell c, ZZCell handleCell,
		float fract, Point p, int xalign, int yalign, int depth) {
	return centerFlob(into, c, handleCell, fract, p, xalign, yalign,
			  depth, null);
    }

    /** A routine to add solid background colors according to scheme 1.
     * No better place to put it right now, but this routine can be
     * called from anywhere to color the background of a cellbgflob
     * as requested.
     * Also adds line cursors, if any.
     */
    static public void addSolidColors(FlobSet into, Flob f, Colorer col) {
	// Special case check: Is this a cursor or a cursor's clone?
	ZZCell orig = f.c.h("d.clone", -1);
	if(orig.h("d.cursor-list", -1).s("d.cursor", -1)
	   != null) {
	    col.addColor(ZZCursorReal.getColorOrWhite(orig));
	    return; // XXX should draw line cursors!
	}
	
	Enumeration e = ZZCursorReal.getPointers(f.c);
	while(e.hasMoreElements()) {
	    ZZCell cu = (ZZCell)e.nextElement();
	    Color color = ZZCursorReal.getColor(cu);
	    if(color != null) if(col.addColor(color)) return;
	    if(!(f instanceof CellFlob1)) continue;
	    int offs = ZZCursorReal.getOffs(cu);
	    if(offs == ZZCursor.NO_OFFSET) continue;
	    int x = ((CellFlob1)f).getStrX(offs);
	    into.add(new LineDecor(x, f.y, x, f.y+f.h, 
		Color.black, f.d));
	}
	
	// XXX Does not check whose mark it is - should!
	if(f.c.s("d.mark-set", 1)!=null)
	    if(col.addColor(Color.red)) return;
	
	if(f.c.s("d.clone", -1) != null)
	    if(col.addColor(Color.yellow)) return;
	else if(f.c.s("d.clone", 1) != null)
	    if(col.addColor(new Color(255, 255, 192))) return;
	
	if(ZZGroupHighlightCache.isMember(f.c)) {
            if(col.addColor(new Color(255, 192, 255))) return;
        }

    }

}


// vim: set syntax=java :
