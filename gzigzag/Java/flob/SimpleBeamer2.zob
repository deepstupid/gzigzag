/*   
SimpleBeamer2.zob
 *    
 *    Copyright (c) 1999-2000, Ted Nelson and Tuomas Lukka
 *
 *    You may use and distribute under the terms of either the GNU Lesser
 *    General Public License, either version 2 of the license or,
 *    at your choice, any later version. Alternatively, you may use and
 *    distribute under the terms of the XPL.
 *
 *    See the LICENSE.lgpl and LICENSE.xpl files for the specific terms of 
 *    the licenses.
 *
 *    This software is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the README
 *    file for more details.
 *
 */
/*
 * SimpleBeamer written by Tuomas Lukka
 */
/*
 * SimpleBeamer2 (based on SimpleBeamer) by Kimmo Wideroos
 */
 

package org.gzigzag;
import java.awt.*;
import java.awt.event.*;
import java.util.*;

/** A decorator which draws lines between overlapping SpanFlobs.
 */

public class SimpleBeamer2 implements FlobDecorator {
public static final String rcsid = "";
    public static boolean dbg = false;
    static final void p(String s) { if(dbg) System.out.println(s); }
    static final void pa(String s) { System.out.println(s); }

    STRUCTPARAMS {

	/** The depth where to put the beam graphics.
	 */
	int depth 
	    = 0;

    }

    // Used for checking whether the connection between two spans
    // is handled already.
    private class Pair {
	Object a; Object b;
	public Pair(Object a, Object b) {
	    this.a = a; 
	    this.b = b;
	}
	public int hashCode() {
	    return a.hashCode() ^ b.hashCode();
	}
	public boolean equals(Object o) {
	    Pair p = (Pair)o;
	    return (a==p.a && b==p.b) || (b==p.a && a==p.b);
	}
    }

    static public Color getSpanColor() {
        return new Color(
            (float)(Math.random() + 1) / 2,
            (float)(Math.random() + 1) / 2,
            (float)(Math.random() + 1) / 2
        );
    }

    static public Color getSpanColor(long seed) {
        int r, g, b;
        int i = (int)(seed & 255);
        r = ((i & 1) << 4) + ((i & 32) >> 2);
        g = ((i & 2) << 3) + ((i & 16) >> 1);
        b = (i & 8) + ((i & 4) << 2);
        return new Color(100+r*4, 50+g*4, 100+b*4);
    }

    int[] xy = new int[16];

    protected void putBeam(BeamDecor2.Builder cb,
				SpanFlob[] sfs, Span[] sps,
				  Color c, boolean new_beam) {
	p("Putbeam");
	int ssep = (int)(sps[0].getStartOffs() - sps[1].getStartOffs());
	int esep = (int)(sps[0].getEndOffs() - sps[1].getEndOffs());

	int x0=0, x1=0, w0=(int)sps[0].length(), w1=(int)sps[1].length();

	if(ssep > 0) x1 = ssep;
	else x0 = -ssep;

	if(esep > 0) w0 -= esep;
	else w1 += esep;

	Rectangle r0 = sfs[0].getRectangle(x0, w0);
	Rectangle r1 = sfs[1].getRectangle(x1, w1);

	Rectangle a=null;
	xy[0] = r0.x; xy[1] = r0.y;
	xy[2] = r0.x; xy[3] = r0.y+r0.height;
	xy[4] = r0.x+r0.width; xy[5] = r0.y+r0.height;
	xy[6] = r0.x+r0.width; xy[7] = r0.y;
	xy[8] = r1.x; xy[9] = r1.y;
	xy[10] = r1.x; xy[11] = r1.y+r1.height;
	xy[12] = r1.x+r1.width; xy[13] = r1.y+r1.height;
	xy[14] = r1.x+r1.width; xy[15] = r1.y;

	cb.c(xy, c, new_beam);

    }

    /** Return: whether to continue.
     */
    static boolean moveBack( SpanFlob[] sfs,
			 Span[] spans) {
	long l1 = spans[0].getStartOffs();
	long l2 = spans[1].getStartOffs();
	if(l1 == l2) {
	    // Check if previous spans end at same point.
	    sfs[0] = sfs[0].getPrev(); if(sfs[0] == null) return false;
	    sfs[1] = sfs[1].getPrev(); if(sfs[1] == null) return false;
	    spans[0] = sfs[0].getSpan(); if(spans[0] == null) return false;
	    spans[1] = sfs[1].getSpan(); if(spans[1] == null) return false;
	    if(spans[0].getEndOffs() != spans[1].getEndOffs()) return false;
	    return true;
	}
	if(l1 > l2) {
	    Span tmp = spans[0];
	    sfs[0] = sfs[0].getPrev(); if(sfs[0] == null) return false;
	    spans[0] = sfs[0].getSpan(); if(spans[0] == null) return false;
	    return spans[0].isAppendable(tmp);
	} else {
	    Span tmp = spans[1];
	    sfs[1] = sfs[1].getPrev(); if(sfs[1] == null) return false;
	    spans[1] = sfs[1].getSpan(); if(spans[1] == null) return false;
	    return spans[1].isAppendable(tmp);
	}
    }
    static boolean moveForw( SpanFlob[] sfs,
			 Span[] spans) {
	long l1 = spans[0].getEndOffs();
	long l2 = spans[1].getEndOffs();
	if(l1 == l2) {
	    // Check if previous spans end at same point.
	    sfs[0] = sfs[0].getNext(); if(sfs[0] == null) return false;
	    sfs[1] = sfs[1].getNext(); if(sfs[1] == null) return false;
	    spans[0] = sfs[0].getSpan(); if(spans[0] == null) return false;
	    spans[1] = sfs[1].getSpan(); if(spans[1] == null) return false;
	    if(spans[0].getStartOffs() != spans[1].getStartOffs()) return false;
	    return true;
	}
	if(l1 < l2) {
	    Span tmp = spans[0];
	    sfs[0] = sfs[0].getNext(); if(sfs[0] == null) return false;
	    spans[0] = sfs[0].getSpan(); if(spans[0] == null) return false;
	    return tmp.isAppendable(spans[0]);
	} else {
	    Span tmp = spans[1];
	    sfs[1] = sfs[1].getNext(); if(sfs[1] == null) return false;
	    spans[1] = sfs[1].getSpan(); if(spans[1] == null) return false;
	    return tmp.isAppendable(spans[1]);
	}
    }

    public void decorate(final FlobSet into, final String path, 
			final ZZCell view) {

	p("Putting beams...");
	final BeamDecor2.Builder bb = new BeamDecor2.Builder(into);

	final SpanSet ss = new SpanTree();

	final Hashtable done = new Hashtable();

	final SpanFlob[] sfs = new SpanFlob[2];
	final Span[] sps = new Span[2];
	final Span[] sps0 = new Span[2];

	// Starts from the surface, goes deeper.
	// BeamDecor renders first-put ones last, which is
	// exactly right for this.

	// XXX WRONG! 
	// ss gets added things so that the span gets
	// drawn when the deeper one is reached, not earlier.
	// hmm...
	into.iterDepth(new FlobSet.DepthIter() {
	public void act(Flob[] flobs, int start, int n) {
	    bb.startl((n+8)*4, depth);
	    for(int f = start; f<start+n; f++) {
		Flob cur = flobs[f];
		if(!(cur instanceof SpanFlob)) continue;
		SpanFlob sf = (SpanFlob)cur;
		Span sp = sf.getSpan();
		p("SF: "+sf+" "+sp);
		if(sp == null) continue;
		if(sp.length() == 0) continue;

		Object[] ovs = ss.overlaps(sp);
		ss.addSpan(sp, sf);
		p("Objs: "+ovs+" "+ovs.length);
		if(ovs.length > 0) {
		    p("Obj: "+ovs[0]);
		} else continue;


		for(int i=0; i<ovs.length; i++) {
		    Pair pa = new Pair(sf, ovs[i]);
		    if(done.get(pa) != null)
			continue;
		    //Color c = getSpanColor();

		    sfs[0] = sf; sps[0] = sfs[0].getSpan();
		    sfs[1] = (SpanFlob)ovs[i]; sps[1] = sfs[1].getSpan();
                    
                    Color c = getSpanColor(sps[0].getStartOffs()+sps[1].getStartOffs());

		    sps0[0] = sps[0]; sps0[1] = sps[1];

		    putBeam(bb, sfs, sps, c, true);
		    done.put(pa, pa);

		    while(moveBack(sfs, sps))  {
			putBeam(bb, sfs, sps, c, false);
			done.put(new Pair(sfs[0], sfs[1]), pa);
		    }

		    sfs[0] = sf; sps[0] = sps0[0];
		    sfs[1] = (SpanFlob)ovs[i];  sps[1] = sps0[1];

		    while(moveForw(sfs, sps))  {
			putBeam(bb, sfs, sps, c, false);
			done.put(new Pair(sfs[0], sfs[1]), pa);
		    }

		}
	    }
	}}, false);

	bb.endl();
	p("Beams finished.");
    }

}

// vim: set syntax=java :
