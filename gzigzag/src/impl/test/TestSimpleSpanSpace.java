/*   
TestPermanentSpace.java
 *    
 *    Copyright (c) 2001, Benja Fallenstein
 *
 *    You may use and distribute under the terms of either the GNU Lesser
 *    General Public License, either version 2 of the license or,
 *    at your choice, any later version. Alternatively, you may use and
 *    distribute under the terms of the XPL.
 *
 *    See the LICENSE.lgpl and LICENSE.xpl files for the specific terms of 
 *    the licenses.
 *
 *    This software is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the README
 *    file for more details.
 *
 */
/*
 * Written by Benja Fallenstein
 */

package org.gzigzag.impl;
import org.gzigzag.*;
import org.gzigzag.vob.*;
import org.gzigzag.mediaserver.*;
import junit.framework.*;
import java.io.*;
import java.util.*;

/** Test SimpleSpanSpace
 */

public abstract class TestSimpleSpanSpace extends TestCase {
public static final String rcsid = "$Id: TestSimpleSpanSpace.java,v 1.60 2002/03/16 18:35:18 bfallenstein Exp $";

    static boolean dbg = false;
    static void p(String s) { if(dbg) System.out.println(s); }

    public TestSimpleSpanSpace(String s) { super(s); }

    abstract public void setUp() throws Exception;

    SimpleSpanSpace space;

    String s1, s2, s3, s4, s5;
    Cell c1, c1c, c2, c3, c4, c5;
    
    Cell vs = Dims.d_vstream_id;
    VStreamDim dim;
    Dim vdim;

    TransientTextScroll block;


    /** Print and sanity-check a range.
     */
    public void printRange(String title, Cell c1) {
	//LinkedVStreamDim dim = (LinkedVStreamDim)this.dim;
	p(title);
	int[] index = new int[1];
	Cell prev = null;

	for(Cell d = c1; d != null; d = vdim.s(d, 1))  {
	    TextSpan sp = (TextSpan)d.getSpan();
	    Cell neg = vdim.s(d, -1);
	    p("Cell: "+d.id+" "+"text: "+d.t()+" span: "+sp+
		" spantext: "+
		    (sp != null ? sp.getText() : "null"));
	    p("                negstep: "+
				    (neg != null ? neg.id : "null"));
	    /*
	    LinkedVStreamDim.Block blo = 
	    	    dim.getBlock(d.id, index);
	    if(blo != null)
	    p("                BLOCK: "+index[0]+" of "+blo);

	    assertEquals(prev, neg);
	    if(neg != null) {
		// Test that this connection is correctly stored.
		LinkedVStreamDim.Block negblo = 
			dim.getBlock(neg.id, index);

		if(negblo != blo) {
		    Object negright = (negblo!=null ? negblo : (Object)neg.id);
		    Object posright = (blo != null ? blo : (Object)d.id);

		    Object negwrong = (negblo != null ? neg.id : null);
		    Object poswrong = (blo != null ? d.id : null);

		    assertEquals(posright, dim.cp.get(negright));
		    assertEquals(negright, dim.cn.get(posright));
		    assertNull(dim.cp.get(negwrong));
		    assertNull(dim.cn.get(poswrong));
		}

	    }
	    */
	    prev = d;
	}

    }

    static public class TSimpleSpan extends TestSimpleSpanSpace {

	/** Test that the isContinuous routine works right.
	 */
	public void testIsContinuous() throws Exception {
	    //LinkedVStreamDim dim = (LinkedVStreamDim)this.dim;
	    Cell cc = space.makeSpanRank("foobar");
	    Cell d = dim.s(cc, 1);
	    assertNotNull("The other cell", d);
//	    assertTrue("The two cells "+c+" and "+d+" should be continuous",
//			dim.isContinuous(c, d));
	}

	/** Test that the different cells in a span are stored in the same
	 *  <code>LinkedVStreamDim.Block</code>.
	 */
	public void testBlockStorage() {
	    //LinkedVStreamDim dim = (LinkedVStreamDim)this.dim;
	    Cell c = space.makeSpanRank("foobar");
/*	    LinkedVStreamDim.Block b = dim.getBlock(c.id, null);
	    assertNotNull("The connections of a stream generated by makeSpanRank "+
			  "were not stored in a LinkedVStreamDim.Block.", b);
	    assertEquals("The LinkedVStreamDim.Block that should contain "+
			 "the connections of a stream generated by makeSpanRank "+
			 "did not have the same length as that stream.",
			 6, b.length());
*/
	}

	public void testConnect() {
	    //LinkedVStreamDim dim = (LinkedVStreamDim)this.dim;
	    Cell c = space.makeSpanRank("foobar");
	    p("TestConnect-1: ");
	    for(Cell d = c1; d != null; d = vdim.s(d, 1)) 
		p("Cell: "+d.id);

	    p("TestConnect0: ");
	    for(Cell d = c; d != null; d = vdim.s(d, 1)) 
		p("Cell: "+d.id);

//	    assertTrue(!dim.isContinuous(c1.id, dim.getBlock(c.id)));

	    c1.connect(vdim, c);

//	    p("POSCONNS: "+dim.cp);
//	    p("NEGCONNS: "+dim.cn);

	    p("TestConnect: ");
	    for(Cell d = c1; d != null; d = vdim.s(d, 1)) 
		p("Cell: "+d.id);
	    int[] index = new int[1];
//	    LinkedVStreamDim.Block b = dim.getBlock(vdim.s(c1, 1).id, index);
//	    assertEquals(0, b.first);
//	    assertEquals(0, index[0]);
	}

	public TSimpleSpan(String s) { super(s); }

	public void setUp() throws Exception {
	    space = new SimpleSpanSpace();
	    dim = space.getVStreamDim();
	    vdim = (Dim)dim;
	    block = space.scroll;
	    
	    c1 = space.N();
	    c2 = space.N();
	    c3 = space.N();
	    c4 = space.N();
	    c5 = space.N();
	    c1c = c1.zzclone();
	}
    }

    static public class TPermanentSpace extends TestSimpleSpanSpace {

	public TPermanentSpace(String s) { super(s); }

	public void setUp() throws Exception {
	    space = new PermanentSpace(TestImpl.zms);
	    dim = space.getVStreamDim();
	    vdim = (Dim)dim;
	    block = space.scroll;

	    c1 = space.N();
	    c2 = space.N();
	    c3 = space.N();
	    c4 = space.N();
	    c5 = space.N();
	    c1c = c1.zzclone();	
	}

    }

    /** Test whether the cells are in the right spaces.
     */
    public void testSpaces() throws Exception {
	TextSpan sp1 = block.append('c');
	Cell c = space.makeSpanRank(sp1);
	assertEquals(c1.space, c.space);
	assertEquals(c, space.getCell(c.id));
    }
    

    /** Test putting external spans into the space.
     */
    public void testOwnSpans() throws Exception {
	p("TESTOWNSPANS:");
	TextSpan sp1 = block.append('c');
	Cell c = space.makeSpanRank(sp1);
	p("C: "+c.id+" C1:"+c1.id);
	c1.connect(vs, c);

	assertEquals("c", c1.t());

	TextSpan sp2 = block.append('1');
	c = space.makeSpanRank(sp2);
	c1.h(vs, 1).connect(vs, c);

	int[] index = new int[1];

	printRange("TestOwnSpans-1: ", c1);

	assertEquals("c1", c1.t());

        assertEquals("c", c1.s(vs).t());
        assertEquals("1", c1.s(vs, 2).t());
        assertEquals(null, c1.s(vs, 3));

	c = space.makeSpanRank(sp1);
	c1.h(vs, 1).connect(vs, c);

	assertEquals("c1c", c1.t());
	assertEquals("c1c", c1c.t());

	TextSpan sp = (TextSpan)sp1.append(sp2);
	c = space.makeSpanRank(sp);
	c2.connect(vs, c);

	assertEquals("c1", c2.t());

	assertEquals("c", c2.s(vs).t());
	assertEquals("1", c2.s(vs, 2).t());
	assertEquals(null, c2.s(vs, 3));
    }

    public void testSpaceSpans() throws Exception {
	Cell c = space.makeSpanRank("blubber");
	c1.connect(vs, c);

	assertEquals("blubber", c1.t());

	Cell curs = space.N();
	Cursor.set(curs, c1.h(vs, 1), 1);
	Cells.vStreamInsert(dim, curs, space.makeSpanRank("-blah"));
	
	assertEquals("blubber-blah", c1.t());

	Cursor.set(curs, c1, 1);
	Cells.vStreamInsert(dim, curs, space.makeSpanRank("foo-"));

	assertEquals("foo-blubber-blah", c1.t());

	printRange("SpaceSpans-1: ", c1);
	dim.removeRange(c1.s(vs, 4), c1.s(vs, 11));

	assertEquals("foo-blah", c1.t());

	assertEquals(null, c1.s(vs, 9));

	
	try {
	    dim.removeRange(c1.s(vs, 5), c1.s(vs, 3));
	    fail("no exception");
	} catch(ZZError _) {
	}

	try {
	    dim.removeRange(c1.s(vs, 3), c4);
	    fail("no exception");
	} catch(RuntimeException _) {
	} catch(ZZError _) {
	}

	assertEquals("foo-blah", c1.t());

	Cursor.set(curs, c1.s(vs, 5), -1);
	Cells.vStreamInsert(dim, curs, space.makeSpanRank("baz-"));

	assertEquals("foo-baz-blah", c1.t());

	// remove range from end

	dim.removeRange(c1.s(vs, 8), c1.h(vs, 1));
	assertEquals("foo-baz", c1.t());
    }

    public void testInsertAtEnd() {
        Cell curs = space.N();
        Cursor.set(curs, c1, -1);
        Cells.vStreamInsert(dim, curs, space.makeSpanRank("foo"));
        Cells.vStreamInsert(dim, curs, space.makeSpanRank("-bar"));
        Cells.vStreamInsert(dim, curs, space.makeSpanRank("-baz"));

	assertEquals("foo-bar-baz", c1.t());
    }

    public void testStreamCloning() {
	/** XXX commented out because stream cloning doesn't work with 
	 *  BlockedVStreamDim -- remove comment when moving to Linked
        Cell curs = space.N();
        Cursor.set(curs, c1, 1);
        Cells.vStreamInsert(dim, curs, space.makeSpanRank("foobar"));
        assertEquals("foobar", c1.t());
	assertEquals("foobar", c1c.t());

	Cursor.set(curs, c2, 1);
	Cells.vStreamInsert(dim, curs, space.makeSpanRank("--"));

	Cursor.set(curs, c2.s(vs), 1);
	Cells.vStreamInsert(dim, curs, c1c);

	assertEquals("-foobar-", c2.t());
	assertEquals(0, dim.getCellOffset(c2.s(vs, 1)));
	// XXX // assertEquals(1, dim.getCellOffset(c2.s(vs, 2)));
	assertEquals(7, dim.getCellOffset(c2.s(vs, 3)));
	
	Cursor.set(curs, c1.s(vs, 3), 1);
	Cells.vStreamInsert(dim, curs, space.makeSpanRank("."));

	assertEquals("-foo.bar-", c2.t());

	dim.removeRange(dim.forCellOffset(c2, 0),
			dim.forCellOffset(c2, 0));

	assertEquals("foo.bar-", c2.t());

	Cursor.set(curs, c2, 1);
	Cells.vStreamInsert(dim, curs, space.makeSpanRank(".oO("));

	assertEquals(".oO(foo.bar-", c2.t());

	dim.removeRange(dim.forCellOffset(c2, 11),
			dim.forCellOffset(c2, 11));

	Cursor.set(curs, c2, -1);
	Cells.vStreamInsert(dim, curs, space.makeSpanRank(")"));
	
	assertEquals(".oO(foo.bar)", c2.t());

	// Cells before the clone.
	assertEquals(c2.s(vs, 2), dim.forCellOffset(c2, 1));
	assertEquals(c2.s(vs, 4), dim.forCellOffset(c2, 3));

	// The clone.
	assertEquals(c2.s(vs, 5), dim.forCellOffset(c2, 4));
	assertEquals(c2.s(vs, 5), dim.forCellOffset(c2, 7));
	assertEquals(c2.s(vs, 5), dim.forCellOffset(c2, 10));

	// After the clone.
	assertEquals(c2.s(vs, 6), dim.forCellOffset(c2, 11));
	assertEquals(null, dim.forCellOffset(c2, 12));
	*/
    }

    public void testSteps() {
//	LinkedVStreamDim dim = (LinkedVStreamDim)this.dim;
	Cell c = space.makeSpanRank("fob"); // 3 cells
	p("Test steps:");
	for(Cell d = c; d != null; d = vdim.s(d, 1)) 
	    p("Cell: "+d.id);
//	p("Block: "+ dim.getBlock(c.id));
//	p("BlockEnd: "+dim.getBlock(c.id).getEnd(1));
	p("Heads: "+vdim.h(c, -1).id+" "+vdim.h(c,1).id);
//	p("POSCONNS: "+dim.cp);
//	p("NEGCONNS: "+dim.cn);
	assertTrue(vdim.h(c, -1) != vdim.h(c, 1));
	Cell d = vdim.s(c, 1);
	assertEquals("o", d.t());
	d = vdim.s(d, 1);
	assertEquals("b", d.t());
	assertEquals(null, vdim.s(d, 1));
	assertEquals(d, c.h(vdim, 1));

	assertEquals(c, c.s(vdim, 1).s(vdim, -1));
	assertEquals(c, c.s(vdim, 2).s(vdim, -2));
	assertEquals(c, c.s(vdim, 1).s(vdim, 1).s(vdim, -1).s(vdim, -1));

	d = space.makeSpanRank("z");
	d.connect(vdim, c);
	c = d;

	assertEquals(c, c.s(vdim, 1).s(vdim, -1));
	assertEquals(c, c.s(vdim, 2).s(vdim, -2));
	assertEquals(c, c.s(vdim, 1).s(vdim, 1).s(vdim, -1).s(vdim, -1));
    }

    String str; int niter;
    public void testIter() {
        Cell curs = space.N();
        Cursor.set(curs, c1, 1);
	Cell c = space.makeSpanRank("foobar");
	// assertEquals("foobar", c.t());
        Cells.vStreamInsert(dim, curs, c);

	p("Iter1: ");
	for(Cell d = c; d != null; d = vdim.s(d, 1)) 
	    p("Cell: "+d.id);

	p("Iter2: ");
	for(Cell d = c1; d != null; d = vdim.s(d, 1)) 
	    p("Cell: "+d.id);



        assertEquals("foobar", c1.t());

        assertEquals("foobar", c1c.t());

	str = ""; niter = 0;
	dim.iterate(new org.gzigzag.vob.CharRangeIter() {
		public void range(Object tag, char[] chars,
				  int first, int last) {
		    assertEquals(space.scroll, tag);
		    str += new String(chars, first, last - first + 1);
		    niter++;
		}
	    }, c1, null);
	assertEquals("foobar", str);
	assertEquals("A text span added as a whole must correspond to " +
		     "a single Iter.range() call", 1, niter);
    }

    /** Return the text of the <code>n</code>th box in the chain. 
     *  Assumes the box is a CharArrayVob-- we're testing CharArrayVobFactory,
     *  after all.
     */
    String text(LinebreakableChain ch, int n) {
	CharArrayVob v = (CharArrayVob)ch.getBox(n);
	return new String(v.chars, v.offs, v.len);
    }

    /** Return whether the <code>n</code>th box in the chain has non-zero glue.
     *  Only looks at the glue length and returns whether that's non-zero.
     */
    boolean glue(LinebreakableChain ch, int n) {
	return ch.getGlue(n, ch.GLUE_LENGTH) != 0;
    }

    /** Test generating a LinebreakableChain of vobs from a vstream.
     *  This is not a unit test, but one that tests whether a number of
     *  units work together correctly: a VStreamDim iterates over a vstream,
     *  performing callbacks into a WordBreaker, which in turn does callbacks
     *  into a CharArrayVobFactory, which places CharArrayVobs into a
     *  LinebreakableChain.
     */
    public void testMakeVobs() {
        Cell curs = space.N();
        Cursor.set(curs, c1, 1);
        Cells.vStreamInsert(dim, curs, space.makeSpanRank(" baz"));
	Cells.vStreamInsert(dim, curs, space.makeSpanRank("bar"));
	Cells.vStreamInsert(dim, curs, space.makeSpanRank("foo "));
        assertEquals("foo bar baz", c1.t());

	TextStyle style = new RawTextStyle(new ScalableFont("serif", 0, 12),
					   java.awt.Color.black);
	CharArrayVobFactory fact = new CharArrayVobFactory(style);
	WordBreaker breaker = new org.gzigzag.vob.WordBreaker(fact);
	dim.iterate(breaker, c1, null);

        LinebreakableChain ch = fact.getChain();

	assertEquals(false, glue(ch, 0));
	assertEquals("foo ", text(ch, 0));
	assertEquals(true, glue(ch, 1));
	assertEquals("bar", text(ch, 1));
	assertEquals(false, glue(ch, 2));
	assertEquals(" ", text(ch, 2));
	assertEquals(true, glue(ch, 3));
	assertEquals("baz", text(ch, 3));
	assertEquals(false, glue(ch, 4));
	assertEquals("", text(ch, 4));
	assertEquals(true, glue(ch, 5));

	assertEquals(5, ch.length());
    }

    public void testGetScrollBlock() {
	assertEquals(space.scroll, space.getTextScroll(space.scroll.getID()));
	try {
	    space.getTextScroll("foo");
	    fail("no exception");
	} catch(Throwable t) {}
    }
    
    /** Test that spans inserted one after another have the same tid. */
    public void testSameTid() {
	Cell c = space.makeSpanRank("abc");
	Cell d = space.makeSpanRank("def");
	int x = c.id.lastIndexOf("$");
	assertEquals(c.id.substring(0, x), d.id.substring(0, x));
    }

    public void testDisconnect() {
	Cell c = space.makeSpanRank("abcd");
	Cell d = space.makeSpanRank("efgh");
	Cell c2 = c.s(vdim, 2);
	c2.disconnect(vdim, 1);
	assertEquals(null, c2.s(vdim, 1));
	c2.connect(vdim, d);
	Cell c1 = c.s(vdim, 1);
	c1.disconnect(vdim,-1);
	assertEquals(null, c.s(vdim, 1));
	assertEquals(d, c2.s(vdim, 1));
	assertEquals(c2, c1.s(vdim, 1));
	c1.disconnect(vdim, 1);
	assertEquals(d, c2.s(vdim, 1));
    }

    public void testSplit() {
	Cell c = space.makeSpanRank("abcdef");
	Cell d = space.makeSpanRank("x");
	Cell e = space.makeSpanRank("ghi");
	Cell cell_f = c.h(vdim, 1);
	c.h(vdim, 1).connect(vdim, e);
	c.s(vdim, 2).disconnect(vdim, 1);
	assertEquals(null, c.s(vdim, 3));
	assertEquals(cell_f, e.s(vdim, -1));
    }

    public void testStringSucc() {
	Cell c = space.makeSpanRank("foobar");
	c1.connect(vdim, c);
	String s = c1.id;
	String s1 = vdim.s(c1).id;

	Cell cfirst = vdim.s(c1);

	if(space instanceof CompoundSpace) {
	    CompoundSpace space = (CompoundSpace)this.space;
	    p("Space for c: "+space.getSpace(c));
	    p("Space for c1: "+space.getSpace(c1));
	}

	assertEquals(cfirst.id, s1);

	Cell cfirsts = space.getCell(s1);
    }

    public void testMakeLoop() {
	try {
	    c1.connect((Dim)dim, c1);
	    fail("no exception when making d.vstream loop");
	} catch(ZZError _) {
	}
	c2.connect((Dim)dim, c3);
	try {
	    c3.connect((Dim)dim, c2);
	    fail("no exception when making d.vstream loop");
	} catch(ZZError _) {
	}
    }

    /** Test whether a scroll is added to space.scrolls when we transclude
     *  a cell from it.
     */
    public void testAddingScroll() throws Exception {
	TransientTextScroll scr = new TransientTextScroll();
	TextSpan sp = scr.append('x');
	space.makeSpanRank(sp);
	assertNotNull(space.scrolls.get(scr.getID()));
    }

    public void testSetGetText() {
	//LinkedVStreamDim dim = (LinkedVStreamDim)this.dim;
	c1.setText("12345");
	printRange("Cell whose text should now be set to 12345", c1);
	// String str = dim.readRange(c1.s(dim), c1.s(dim));

	//CharRangeIter iter = new CharRangeIter() {
	//    public void object(Object o) {
	//	p("Object: "+o);
	//    }
	//    public void range(Object tag, char[] chars, int first, int last) {
	//	p("RANGE: "+chars+" "+first+" "+last);
	//    }
	//};
	//p("ITERATERANGE 1");
	//dim.iterateRange(iter, c1.s(dim), c1.s(dim), null);
	//p("ITERATERANGE 2");
	//dim.printRanges(c1.s(dim));

	//assertEquals("1", str);
	assertEquals("12345", c1.t());
    }

    public void testGetCellId() {
	Cell c = space.makeSpanRank("abcd");
	assertTrue("Should have a spacepart", c.spacepart != null);
	assertTrue(c.spacepart.getInclusionType() == SpanSpacepart.VSTREAM_PART);
	assertTrue(c.inclusionObject != null);
    }
}
